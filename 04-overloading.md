## Operator overloading

### Copy assignment
``` cpp
auto fsv::filtered_string_view::operator=(const filtered_string_view &other) noexcept -> filtered_string_view& {
    if (this == &other) {
        return *this;
    }

    data_ = other.data_;
    size_ = other.size_;
    predicate_ = other.predicate_;

    return *this;
}
```

### Move assignment
``` cpp
auto fsv::filtered_string_view::operator=(filtered_string_view &&other) noexcept -> filtered_string_view& {
    if (this == &other) {
        return *this;
    }

    delete[] data_;

    data_ = other.data_;
    size_ = other.size_;
    predicate_ = other.predicate_;

    other.data_ = nullptr;
    other.size_ = 0;
    other.predicate_ = default_predicate;

    return *this;
}

```

### Subscript
``` cpp
auto fsv::filtered_string_view::operator[](int n) const -> const char & {
    auto it = begin();
    for (int i = 0; i < n; i++) {
        if (it == end()) {
            throw std::out_of_range("Index out of range");
        }
        ++it;
    }
    if (it == end()) {
        throw std::out_of_range("Index out of range");
    }
    return *it;
}
```

### String type conversion
``` cpp
fsv::filtered_string_view::operator std::string() const {
    auto result = std::string{""};

    for (auto p = data_; *p != '\0'; ++p) {
        if (predicate_(*p)) {
            result.push_back(*p);
        }
    }

    return result;
}
```

### Equality Comparison operator
``` cpp
// the inequality operator is automatically generated by the compiler if operator== is defined
friend auto operator==(const filtered_string_view &lhs, const filtered_string_view &rhs) noexcept -> bool {
    auto first = static_cast<std::string>(lhs);
    auto second = static_cast<std::string>(rhs);

    return first == second;
}  // Equality Comparison
```

### Three-way comparison operator
``` cpp
// the four relational operators automatically generated by the compiler if the three-way comparison operator is defined
friend auto operator<=>(const filtered_string_view &lhs, const filtered_string_view &rhs) noexcept -> std::strong_ordering {
    auto first = static_cast<std::string>(lhs);
    auto second = static_cast<std::string>(rhs);

    auto data_ord = first <=> second;

    return data_ord;
}  // Relational Comparison
```

### IOstream operator
``` cpp
friend auto operator<<(std::ostream &os, const filtered_string_view &fsv) noexcept -> std::ostream& {
    for (auto i : fsv) {
        os << i;
    }
    return os;
}    // outstream
```

## Custom iterators

### Iterator traits
- every iterator has certain required type members
  - iterator category
  - value type
  - reference type
  - pointer type
  - difference type

``` cpp
// iterator traits for an iterator
// modelling an int*

// <iterator> contains the category tags
#include <iterator>

class iter {
public:
  using iterator_category
    = std::contiguous_iterator_tag;
    
  using value_type = int;
  
  using reference_type = value_type&;
  
  using pointer_type = value_type*;
  // could also do pointer_type = void;
  
  // usually std::pointerdiff_t is sufficient
  using difference_type = std::pointerdiff_t;
};
```

### From a container to a range
- a range is a container with certain member types and functions
- member types
  - iterator
  - const_iterator
  - bidirectional and greater iterators also require
    - reverse_iterator
    - const_reverse_iterator
- member functions
  - begin(), end()
  - cbegin(), cend()
  - bidirectional and greater iterators also require
    - rbegin(), rend()
    - crbegin(), crend()

``` cpp
class vector {
  struct iter { /* implementation */ };
public:
  using iterator = iter;
  using const_iterator = /* to be defined */;
  using reverse_iterator = /* to be defined */;
  using const_reverse_iterator = /* to be defined */;
  
  iterator begin();
  iterator end();
  const_iterator begin() const;
  const_iterator end() const;
  const_iterator cbegin() const;
  const_iterator cend() const;
  
  reverse_iterator rbegin();
  reverse_iterator rend();
  const_reverse_iterator rbegin() const;
  const_reverse_iterator rend() const;
  const_reverse_iterator crbegin() const;
  const_reverse_iterator crend() const;
}; 
```

### Example
``` cpp
class iter {
public:
    using POINTER_TYPE = void;

    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = char;
    using reference_type = const char &;
    using pointer_type = POINTER_TYPE;
    using difference_type = std::ptrdiff_t;

    // default constructor
    iter() = default;

    iter(const filtered_string_view& fsv, const char* ptr)
        : ptr_{ptr}, end_{fsv.data_ + fsv.size_}, predicate_{fsv.predicate_} {
            if (ptr_ != end_ && !predicate_(*ptr_)) {
                ++(*this);
            }
        }

    auto operator*() const -> reference_type {
        return *ptr_;
    }
    auto operator->() const -> pointer_type; 

    auto operator++() -> iter& {
        ++ptr_;
        while (ptr_ != end_ && !predicate_(*ptr_)) {
            ++ptr_;
        }
        return *this;
    }

    auto operator++(int) -> iter {
        iter tmp{*this};
        ++(*this);
        return tmp;
    }

    auto operator--() -> iter& {
        --ptr_;
        while (ptr_ != end_ && !predicate_(*ptr_)) {
            --ptr_;
        }
        return *this;
    }

    auto operator--(int) -> iter {
        iter tmp{*this};
        --(*this);
        return tmp;
    }

    friend auto operator==(const iter& lhs, const iter& rhs) -> bool {
        return lhs.ptr_ == rhs.ptr_;
    }

    friend auto operator!=(const iter& lhs, const iter& rhs) -> bool {
        return !(lhs == rhs);
    }

private:
    const char* ptr_;
    const char* end_;
    filter predicate_;
};
```

``` cpp
using iterator = iter;
using const_iterator = iter;
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;

auto begin() const -> iterator {
    return iter(*this, data_);
}
auto end() const -> iterator {
    return iter(*this, data_ + size_);
}
auto cbegin() const -> const_iterator {
    return iter(*this, data_);
}
auto cend() const -> const_iterator {
    return iter(*this, data_ + size_);
}
auto rbegin() -> reverse_iterator {
    return reverse_iterator(end());
}
auto rend() -> reverse_iterator {
    return reverse_iterator(begin());
}
auto rbegin() const -> const_reverse_iterator {
    return const_reverse_iterator(cend());
}
auto rend() const -> const_reverse_iterator {
    return const_reverse_iterator(cbegin());
}
auto crbegin() const -> const_reverse_iterator {
    return const_reverse_iterator(cend());
}
auto crend() const -> const_reverse_iterator {
    return const_reverse_iterator(cbegin());
}
```
